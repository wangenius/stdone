---
title: 树和二叉树
date: 2023-02-18T13:04:02.302Z
slug: tree
src: "../../images/kelly-sikkema-Hl3LUdyKRic-unsplash.jpg"
alt: "First Markdown Post"
author: "wangenius"
description: "在计算机科学中，树（英语：tree）是一种抽象数据类型 (opens new window)
（ADT）或是实现这种抽象数据类型的数据结构 (opens new window)，用来模拟具有树状结构 (opens new window)
性质的数据集合。它是由 n（n>0）个有限节点组成一个具有层次关系的集合 (opens new window)
。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。
它具有以下的特点：
每个节点都只有有限个子节点或无子节点。
树有且仅有一个根节点。
根节点没有父节点；非根节点有且仅有一个父节点。
每个非根节点可以分为多个不相交的子树。
树里面没有环路。"
type:
- system
- data structure

---

## 定义和基本概念

> 非线性数据结构-分支关系定义

任意非空树中有且仅有一个root 结点,其余节点为m个互不相交的有限集,该有限集根的子树.

### 抽象数据类型树:

```c 
ADT Tree{
    数据对象
    数据关系
    基本操作
}
```

树的结点：一个数据元素和若干指向其他子树的分支

结点的度：分支个数

树的结点：最大的度

叶子：度为0的结点

分支结点：度不为0的结点

关系：child、parent、sibling、ancestor、offspring

层次：root为第一层

深度：最大层次

有序无序：sibling左右有序

森林：m棵互不相交的树的集合

### 二叉树

> 度小于2的有序树

满二叉树:所有度都为2的二叉树

完全二叉树:与编号一一对应,特点:
叶子只可能在层次最大的两层出现,`任意结点的左分支深度= 右分支深度或右分支深度 + 1`

#### 特性

1. 二叉树的第$i$层至多有$2^{i-1}$个结点
2. 深度为k的二叉树至多有${2^k-1}$结点
3. **对于任何一棵二叉树T,其终端节点数为n0,度为2的结点数为n2,则$n_0 = n_2 + 1$**
4. 具有n个结点的完全二叉树的深度为${Math.floor({log_2n}) + 1}$
5. 具有n个结点的完全二叉树,对于任意节点$i$:
    1. $i=1$,根节点,结点无双亲,$i>1$,其双亲$PARENT(i)$是$Math.floor(i / 2)$
    2. 如果$2i>n$,则结点$i$无左叶,否则其左叶是$2i$
    3. 如果$2i + 1 > n$,则结点$i$无右叶,否则其右叶是结点$2i+1$

#### 二叉树的储存结构

1. 顺序储存结构 仅适用于完全二叉树
2. 链式储存结构 结点至少数据域\左指针域\右指针域,还可能有双亲域 二叉链表\三叉链表
    1. 含有$n$个结点的二叉链表有$n+1 $个空链域

### 遍历二叉树和线索二叉树

#### 遍历二叉树

二叉链表与栈||遍历顺序和递归算法

> 对一个非线性结构进行线性化操作,是每个节点在这些线性序列中有且仅有一个直接前驱和直接后继

1. 先序遍历
    1. 访问根节点
    2. 先序遍历左子树
    3. 先序遍历右子树
2. 中序遍历
    1. 中序遍历左子树
    2. 访问根节点
    3. 中序遍历后子树
3. 后序遍历
    1. 后序遍历左子树
    2. 后序遍历右子树
    3. 访问根节点

**递归算法和非递归算法**

```c
//递归算法
Status PreOrderTraverse(BiTree T,Status(* Visit)(TElemType e)){
   if(T){
       Visit(T->data)
           if(PreOrderTraverse(T->lchild,Visit))
               if(PreOrderTraverse(T->rchild,Visit)) return OK;
       return error;
   }
    else return OK;
}
//非递归算法
Status InOrderTraverse(BiTree T, Status (* Visit)(TElemType e)){
    InitStack(S);//根指针进栈
    Push(S,T);
    while(!StackEmpty(S)){
        while(GetTop(S,p) && p) Push(S,p->lchild);
        Pop(S,p);
        if(!StackEmpty(S)){
            Pop(S,p);if(!Visit(p->data)) return ERROR;
            Push(S,P->child);
        }
    }
    return OK;
}
```

> **对含n个结点的二叉树,其时间复杂度均为$O(n)$,所需辅助空间为遍历过程中栈的最大容量,即树的深度.最坏情况下为n.

#### 线索二叉树

>
空链域存放结点的前驱后继的信息，为了避免混淆尚需改变结点结构，增加两个标志域。这种结点结构构成的二叉链表作为二叉树的储存结构，叫做线索链表。指向前驱和后继的指针叫做**
线索**，加上 线索的二叉树叫做**线索二叉树**
>
> 对二叉树以某种次序遍历使其变为线索二叉树的过程叫做**线索化**

##### 找到结点的前驱后继

1. 后继 中序遍历的后继遍历其右子树时访问的第一个结点
2. 前驱 中序遍历的前驱遍历其左子树时访问的最后一个结点

后续线索树寻找后继：

1. 根没有后继
2. x是双亲的右孩子或者x是左孩子且双亲没有右孩子时，x的后继是双亲结点
3. x是双亲的左孩子且双亲有右孩子时，后继是双亲的右子树上按后续遍历列出的第一个结点

> 在后序线索化树上找后继时需要知道结点双亲,即需带标志域的三叉链表作为储存结构

> 在中序线索二叉树上遍历二叉树,虽则时间复杂度同样是$O(n)$
> ,但常数因子要比中序遍历二叉树的算法小,且不需要设栈,因此在程序中所用二叉树需要经常遍历或查找结点在遍历所得线性序列中的前驱和后继,因采用线索链表作为储存结构.

**双向线索链表**

在二叉树的线索链表上也添加一个头节点,令其lchild指针指向二叉树的根节点,其rchild指针指向中序遍历时访问的最后一个结点,反之,令二叉树中序序列中的第一个结点的lchild域指针和最后一个系欸但的rchild域指针均指向头节点.既可以从第一个结点起顺后继进行遍历,也可以从最后一个结点起顺前驱进行遍历.

线索化的实质是将二叉链表中的空指针改成指向前驱或者后继的线索,即线索化的过程即为在遍历过程中修改空指针的过程.

### 树和森林

#### 树的储存结构

1. 双亲表示法

   在每个结点中附设一个指示器指示其双亲结点在链表中的位置,![dfgsdrgdsfgdsrgds](http://39.96.54.181:88/note/dfgsdrgdsfgdsrgds.jpg)

2. 孩子表示法

    1. 固定指针域:浪费很多空链域

    2. 不同构指针域:节约储存空间但是操作不方便

    3. 每个结点的孩子结点排列起来,看成一个线性表,且以单链表作为储存结构,则n个结点有n个孩子链表
       n个头指针又组成一个线性表

       ![sdfgsdrgdsfgdfshfhfg](http://39.96.54.181:88/note/sdfgsdrgdsfgdfshfhfg.jpg)

3. 孩子兄弟表示法

   又称二叉树表示法,二叉链表表示法.两个链域分别指向该节点的第一个孩子结点和下一个兄弟结点

#### 森林与二叉树的转换

> 树和二叉树的二叉链表的物理结构是相同的,只是解释不同,树的左指针域是子树,右指针域是兄弟树

森林$F={\{T_1,T_2,···,T_m\}}$和二叉树$B=(root,LB,RB)$的相互转换

1. F转B:
    1. F为空,B为空
    2. LB是T1的根节点的子树森林转换而成的二叉树
    3. RB是${T_2,T_3,···,T_m}$转换而成的二叉树
2. B转F:
    1. B为空,F为空
    2. T1的根是B的根,T1的根节点的子树森林F1是由B的左子树LB转换而成的森林
    3. F中的其余子树组成的森林是由B的右子树转换而成的森林

#### 树和森林的遍历

树的遍历:先根遍历树,后根遍历树

森林的遍历:

1. 先序遍历森林
    1. 访问森林中第一棵树的根节点
    2. 先序遍历第一棵树的根节点的子树森林
    3. 先序遍历除第一棵树后剩余树构成的森林
2. 中序遍历森林
    1. 中序遍历森林中第一棵树的根节点的子树森林
    2. 访问第一颗树的根节点
    3. 中序遍历除第一棵树后剩余树构成的森林

## 树与等价问题

树型结构表示集合

//todo

## 赫夫曼树

> Huffman树,又称最优树,是一类带权路径长度最短的树

### 最优二叉树

从树中的一个结点到另一个结点之间的分支构成这两个节点之间的路径,路径上的分支数目称做**路径长度**.

树的路径长度是从树根到每一个结点的路径长度之和

#### 带权路径长度

结点的带权路径长度为从该节点到树根之间的路径长度与结点上权的乘积

树的带权路径长度为书中所有叶子结点的带权路径长度之和通常记作$WPL = \sum_{k=1}^{n} w_k l_k$

#### 利用赫夫曼树得到最佳判定算法,解决某些判定问题

一种严格的(正则的)二叉树,没有度为1的结点,一颗有n个叶子结点的赫夫曼树共有2n-1个结点,可以储存在一个大小为2n-1的一维数组中

#### 赫夫曼算法构造赫夫曼树

1. 根据给定的n个权值构成的n棵二叉树集合,其中每棵二叉树Ti中只有一个带权为wi的根节点,其左右子树都为空.
2. 在F中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树,且置新的二叉树的根节点的权值为其左\右子树上根节点的权值之和.
3. 在F中删除这两棵树,同时将新的到的二叉树加入F中
4. 重复2和3步,知道F中只含一棵树为止,这棵树就是赫夫曼树

#### 赫夫曼编码

前缀编码,人一个字符的编码都不是另一个字符的编码的前缀

#### 求赫夫曼编码

```c
typedef struct{
    unsigned int weight;
    unsigned int parent,lchild,rchild;
}HTNode, * HuffmanTree;
typedef char * *HuffmanCode;


void HuffmanCoding(HuffmanTree &HT,HuffmanCode &HC,int * w,int n){
	//w存放n个字符的权值,构造赫夫曼树HT,并求出n个字符的赫夫曼编码HC
	if	(n<=1) return;
    m = 2 * n - 1;
    HT = (HuffmanTree)malloc((m+1) * sizeof(HTNode));
    for	(p = HT + 1,i=1;i<=n;++i,++p,++w) *p={*w,0,0,0};
    for (; i<=m;++i,++p) * p = {0,0,0,0};
    for (i = n+ 1;i<=m;++i){ //构造赫夫曼树
        //在HT[]选择parent为0且weight最小的两个结点,其序号分别为s1,s2
        Select(HT,i-1,s1,s2);
        HT[s1].parent = i; HT[s2].parent = i;
        HT[i].lchild = s1;HT[i].rchild = s2;
        HT[i].weight = HT[s1].weight + HT[s2].weight;
    }
    
    //从叶子到根逆向求每个字符的赫夫曼编码
    HC= (HuffmanCode)malloc((n+1) * sizeof(char *));
    cd = (char *)malloc(n* sizeof(char));
    cd[n-1] = "\0";
    for(i=1;i<=n;++i){
        start = n -1;
        for (c=i,f=HT[i].parent;f!=0;c=f,f=HT[f].parent)
            if(HT[f].lchild == c) cd[--start] = '0';
        else cd[--start] = "1";
        HC[i] = (char *)malloc((n-start) * sizeof(char));
        strcpy(HC[i],&cd[start]);
    }
    free(cd);
    
    
}
```

//todo译码过程

## 回溯法和树的遍历

Backtracking

#### 求集合幂集

#### 八皇后问题

## 树的计数

> 具有n个结点的不同形态的树有多少棵

二叉树相似是指两者都为空树或者都不为空树,且他们的左右子树分别相似;等价是指,不仅相似,而且所有对应节点上的数据元素均相同.

二叉树的计数问题就是讨论具有n个结点互不相似地二叉树地树木.

$$b_n = \frac{1}{n+1}C_{2n}^{n}$$

> **已知结点的前序序列和中序序列分别为**
>
> 前序序列:A B C D E F G
>
> 中序序列:C B E D A F G
>
> 按上述分解求得整棵二叉树

已知前序序列和中序序列可以确定唯一的一棵二叉树

